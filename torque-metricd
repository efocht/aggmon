#!/usr/bin/python2
##########################################################################
#                                                                        #
#               Copyright (C) 2013 - 2014 NEC HPC Europe.                #
#                                                                        #
#  These coded instructions, statements, and computer programs  contain  #
#  unpublished  proprietary  information of NEC HPC Europe, and are      #
#  are protected by Federal copyright law.  They  may  not be disclosed  #
#  to  third  parties  or copied or duplicated in any form, in whole or  #
#  in part, without the prior written consent of NEC HPC Europe.         #
#                                                                        #
##########################################################################
#
import ConfigParser
import glob
import md5
import os
import re
import signal
import subprocess
import socket
import sys
import syslog
import time
import psutil
from metric_store import MongoDBMetricStore, JMetric, NMetric


# Constants
TORQUE_PROC = "pbs_server"
TORQUE_ACCOUNTING_PATH = "/var/spool/torque/server_priv/accounting"
TORQUE_LOG_MARKER = {"A" : "aborted",         # job has been aborted by server
                     "C" : "checkpointed",    # job has been checkpointed and stopped
                     "D" : "deleted",         # job has been deleted
                     "E" : "exited",          # job has exited (either successfully or unsuccessfully)
                     "Q" : "queued",          # job has been submitted/queued
                     "R" : "rerun",           # an attempt to rerun the job has been made
                     "S" : "started",         # an attempt to start the job has been made
                     "T" : "restarted",       # an attempt to restart the job has been made (after checkpointed)
                    }
LOG_LEVELS = {"error"   : syslog.LOG_ERR,
              "warning" : syslog.LOG_WARNING,
              "info"    : syslog.LOG_INFO,
              "debug"   : syslog.LOG_DEBUG,
             }

global tag_new
global acc_file_dir

config_defaults = {"acc_file_dir" : TORQUE_ACCOUNTING_PATH,
                   "log_level"    : "warning",
                   "mongodb_host" : "localhost",
                   "include_cpus" : "False",
                   "call_tagger"  : "False",
                   "agg_cmd_port" : ""
                  }

config = ConfigParser.RawConfigParser( config_defaults )
config.add_section( "daemon" )
config.read( "/etc/torque-metricd.conf" )
log_level = config.get( "daemon", "log_level" )
acc_file_dir = config.get( "daemon", "acc_file_dir" )
mongodb_host = config.get( "daemon", "mongodb_host" )
include_cpus = config.getboolean( "daemon", "include_cpus" )
call_tagger = config.getboolean( "daemon", "call_tagger" )
agg_cmd_port = config.get( "daemon", "agg_cmd_port" )

try:
    syslog_max_level = LOG_LEVELS[log_level.lower()]
except:
    syslog_max_level = config_defaults["log_level"]
    syslog.syslog( syslog.LOG_WARNING, "unknown log level '%s'! Defaults to 'warning'." % log_level )

syslog.openlog( "torque-metricd", syslog.LOG_PID, syslog.LOG_DAEMON )
syslog.setlogmask( syslog.LOG_UPTO( syslog_max_level ) ) 

syslog.syslog( syslog.LOG_DEBUG, "starting torque-metricd" )
for line in ["configuration:",
             "    acc_file_dir = %(acc_file_dir)s",
             "    mongodb_host = %(mongodb_host)s",
             "    log_level = %(log_level)s"]:
    syslog.syslog( syslog.LOG_INFO, line % locals() )

def sig_handler( sig, frame ):
    if tag_new:
        put_tag( acc_file_dir, tag_new )
    syslog.syslog( syslog.LOG_INFO, "terminating due to SIGTERM..." )
    sys.exit( 0 )

def md5sum( s ):
    m = md5.new()
    m.update( s )
    return m.hexdigest()

def pidof( name ):
    procs = filter(lambda p: p.name == name, psutil.process_iter())
    return [p.pid for p in procs]

def torque_pid():
    while True:
        pids = pidof( TORQUE_PROC )
	if pids:
            return pids[0]
        syslog.syslog( syslog.LOG_INFO, "waiting for Torque (%s) to start..." % TORQUE_PROC )
        time.sleep( 30 )

def is_file_open( pid, file_name ):
    dir = os.path.join( "/proc", str( pid ), "fd" )
    if not os.path.exists( dir ):
        syslog.syslog( syslog.LOG_WARNING, "%s seems to have terminated!" % TORQUE_PROC )
	return False
    if not os.access( dir, os.R_OK | os.X_OK ):
        syslog.syslog( syslog.LOG_ERR, "no permissions to access: %s! Terminating..." % dir )
        sys.exit( 1 )
    for fds in os.listdir( dir ):
        for fd in fds:
            full_name = os.path.join( dir, fd )
            try:
                file = os.readlink( full_name )
                if file == file_name:
                    return True
            except:
                pass
    return False

def tail( pid, file_name ):
    fd = open( file_name )
    fd.seek( 0, 2 )
    sleep = 0.001
    buf = ""
    eof = False
    while is_file_open( pid, file_name ):
        while not eof:
	    # while not at EOF (indicated by readline returning "")
            time.sleep( sleep )
            buf = buf + fd.readline()
            if buf == "":
		eof = True
                if sleep < 1.0:
                    sleep += 0.001
		continue
            sleep = 0.001
	    # complete Torque lines always end with "\n"
	    if buf[-1] != "\n":#
		eof = False
                continue
            line = buf
	    buf = ""
            yield line
        eof = False
    fd.close()

def parse_torque_accounting_log( line ):
    import time
    line = line.strip()
    if not line:
        syslog.syslog( syslog.LOG_WARNING, "ignoring empty line" )
        return None
    try:
        # example header: 08/08/2014 11:32:23;S;50438;<payload>
        comp = line.split( ";", 3 ) 
        assert comp[1] in TORQUE_LOG_MARKER.keys(), "Torque accounting log (unknown event): '%s'" % comp[1]
        timestamp = int( time.mktime( time.strptime( comp[0], "%m/%d/%Y %H:%M:%S" ) ) )    # log (not job) timestamp (time, T)
        value = TORQUE_LOG_MARKER[comp[1]]                                                  # event type (value, V)
        name = comp[2].replace( ".", "_" )                                                  # jobid (name, N)
        payload = comp[3]                                                                   # attribute set
        host_name = socket.gethostname()                                                    # add local hostname
        metric = JMetric( name=name, source="Torque", time=timestamp, host=host_name, value=value )
    except Exception as e:
        syslog.syslog( syslog.LOG_WARNING, "Torque accounting log (parsing header failed): '%s'" % line )
        return None
    for attr_str in payload.split( " " ):
        # example payload: user=myuname group=sthaber jobname=STDIN queue=workq ctime=1407490338 qtime=1407490338 etime=1407490338 start=1407490343
        #     owner=myuname@sb-master exec_host=<exec_host> Resource_List.ncpus=1 Resource_List.neednodes=1:ppn=1:foo:ghz-2.6:mhz-2601:ddr1866:qlogic
        #     Resource_List.nodect=1 Resource_List.nodes=1:ppn=1:foo:ghz-2.6:mhz-2601:ddr1866:qlogic
        attr_str = attr_str.replace( ".", "_" )
        try:
            k, v = attr_str.split( "=", 1 )
        except Exception as e:
            syslog.syslog( syslog.LOG_WARNING, "Torque accounting log (failed to parse attributes): '%s'" % attr_str )
            return None
        if k in ["ctime", "qtime", "etime", "start", "end"]:
            v = int( v )
        elif k in ["user", "group", "jobname", "queue", "owner"]:
            pass
            # any special treatment here?
        elif k == "exec_host":
            # example exec_host: sabi36/19+sabi36/18+sabi36/17+sabi36/16+sabi36/15+sabi36/14+sabi36/13+sabi36/12+sabi36/11...
            nodes = sorted( list( set( [r.split( "/" )[0] for r in v.split( "+" )] ) ) )
            k = "cnodes"
            if include_cpus:
                cpus = {}
                for n in nodes:
                    cpus[n] = sorted( list( set( [int( r.split( "/", 2 )[1] ) for r in v.split( "+" ) if r.split( "/", 2 )[0] == n] ) ) )
                v = cpus
            else:
                v = nodes
        elif k.startswith( "Resource_List" ): 
            k = k.replace( "Resource_List", "RL" )
        metric[k] = v
    return metric

def get_tag( dir ):
    tag_file_name = dir + "/tag"
    tag = None
    if os.path.isfile( tag_file_name ):
        tag = open( tag_file_name ).read().split()[0]
	if tag:
            syslog.syslog( syslog.LOG_DEBUG, "tag file found: %s (%s)" % (tag_file_name, tag) )
        else:
	    tag = None
    return tag

def put_tag( dir, tag ):
    tag_file_name = dir + "/tag"
    open( tag_file_name, "w" ).write( tag )
    syslog.syslog( syslog.LOG_DEBUG, "wrote: %s (%s)" % (tag_file_name, tag) )

try:
    store = None
    if mongodb_host:
        store = MongoDBMetricStore( host_name=mongodb_host )
    else:
        syslog.syslog( syslog.LOG_WARNING, "can't connect to MongoDB! No host name set in configuration file." )
except:
    syslog.syslog( syslog.LOG_ERR, "can't connect to MongoDB! Check auth in mongodb.conf. Terminating..." )
    sys.exit( 1 )

signal.signal(signal.SIGINT, sig_handler)

# import backlog
tag = get_tag( acc_file_dir )
tag_found = False
tag_new = None
file_names = sorted( glob.glob( acc_file_dir + "/[0-9]*" ) )
for file_name in file_names:
    syslog.syslog( syslog.LOG_DEBUG, "importing metrics from: %s" % file_name )
    with open( file_name ) as f:
        for line in f:
            tag_new = md5sum( line )
            if not tag or tag_found:
                metric = parse_torque_accounting_log( line )
                print metric
                if metric:
                    try:
                        store.addMetric( metric )
                        syslog.syslog( syslog.LOG_DEBUG, "stored: %s" % str( metric ) )
                    except Exception as e:
                        syslog.syslog( syslog.LOG_ERR, "failed to store metric: %s, %s" % (type( e ), str( e )) )
            else:
                if tag_new == tag:
                    tag_found = True
if tag_new:
    put_tag( acc_file_dir, tag_new )
if tag and not tag_found:
    syslog.syslog( syslog.LOG_WARNING, "tag (%s) not found in any acc file (%s)!" % (tag, acc_file_dir) )

# tail current accounting file
while True:
    pid = torque_pid()
    file_names = sorted( glob.glob( acc_file_dir + "/[0-9]*" ) )
    if not file_names:
        syslog.syslog( syslog.LOG_WARNING, "no accounting file found in %s, waiting..." % acc_file_dir )
        time.sleep( 30 )
        continue
    file_name = file_names[-1]
    syslog.syslog( syslog.LOG_INFO, "monitoring acc file: %s" % file_name )
    for line in tail( pid, file_name ):
        tag_new = md5sum( line )
        metric = parse_torque_accounting_log( line )
        if metric:
            try:
                store.addMetric( metric )
                syslog.syslog( syslog.LOG_DEBUG, "saved: %s" % str( metric ) )
            except Exception as e:
                syslog.syslog( syslog.LOG_ERR, "can't store metric: %s, %s" % (type( e ), str( e )) )
            if isinstance( metric["cnodes"], dict ):
                regex_str = "|".join( metric["cnodes"].keys() )
            elif isinstance( metric["cnodes"], list ):
                regex_str = "|".join( metric["cnodes"] )
            else:
                syslog.syslog( syslog.LOG_ERR, "internal error! Unknown metric.cnodes type(%s)." % type( metric["cmodes"] ))
                continue
            if call_tagger:
                try:
                    agg_cmd_args = ["python", "agg_cmd.py"]
                    if agg_cmd_port:
                        agg_cmd_args.extend( ["--cmd_port", agg_cmd_port] )
                    if metric["value"] in ["rerun", "started", "restarted"]:
                        agg_cmd_args.extend( ["--add", "J", metric["name"], "H", regex_str] )
                        r = subprocess.call( agg_cmd_args )
                    elif metric["value"] in ["aborted", "checkpointed", "deleted", "exited"]:
                        agg_cmd_args.extend( ["--del", "J", metric["name"]] )
                        r = subprocess.call( agg_cmd_args )
                    if r != 0:
                        syslog.syslog( syslog.LOG_ERR, "calling agg_cmd (%s) failed!" % " ".join( agg_cmd_args ) )
                except:
                    syslog.syslog( syslog.LOG_ERR, "failed to run agg_cmd!" )
